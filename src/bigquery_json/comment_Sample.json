{"post_id":"3904473","Title":"accepting HTTPS connections with self-signed certificates","question_id":"2012497","comment":"From what I understand, this only solves the problem if the certificate chain is correct and in a specific order. There was once a bug in Android related to certificate chain ordering. Perhaps any failures that this solution doesn't resolve are related to that (as I suspect my issue was).","vote":"172"}
{"post_id":"3904473","Title":"accepting HTTPS connections with self-signed certificates","question_id":"2012497","comment":"I updated source code above and added simple example. This code works for you?","vote":"172"}
{"post_id":"3904473","Title":"accepting HTTPS connections with self-signed certificates","question_id":"2012497","comment":"I have a similar doubt. Could you please help https://stackoverflow.com/questions/57389622/client-certificate-based-multifactor-authentication-in-android#","vote":"172"}
{"post_id":"3904473","Title":"accepting HTTPS connections with self-signed certificates","question_id":"2012497","comment":"This is not working for me either. I still get the \"not trusted\" error. Could you show the rest of the code on how to post after all of that. This way we can make sure that we are posting correctly? Thanks","vote":"172"}
{"post_id":"3904473","Title":"accepting HTTPS connections with self-signed certificates","question_id":"2012497","comment":"Can you explain how this code is any better than disabling certificate verification entirely? I'm not familiar with android's ssl API, but at a glance this seems completely insecure against active attackers.","vote":"172"}
{"post_id":"3725042","Title":"Going to home screen programmatically","question_id":"3724509","comment":"@Janusz, when using the above code in OnBackPressed(), getting the crash with java.lang.SecurityException: Permission Denial: starting Intent","vote":"172"}
{"post_id":"3725042","Title":"Going to home screen programmatically","question_id":"3724509","comment":"I'm seeing many crashes on firebase with a similar approach, posted it here and don't have a solution yet: https://stackoverflow.com/questions/55005798/illegalstateexception-cant-change-activity-type-once-set","vote":"172"}
{"post_id":"2240352","Title":"Remove/hide a preference from the screen","question_id":"2240326","comment":"I might have answered my own question through this? http://stackoverflow.com/a/4704360/956975","vote":"172"}
{"post_id":"2240352","Title":"Remove/hide a preference from the screen","question_id":"2240326","comment":"@Dmitry You need to call `removePreference` on the direct parent, which you can get with `getParent()` (see [this answer](https://stackoverflow.com/a/52336537/905686)).","vote":"172"}
{"post_id":"1116273","Title":"How do I calculate someone's age in Java?","question_id":"1116123","comment":"@IgorGanapolsky Indeed the main difference is: Joda-Time use constructors while Java-8 and ThreetenBP use static factory methods. For a subtle bug in the way Joda-Time calculates age, please look at [my answer](http://stackoverflow.com/a/27738766/2491410) where I have given an overview about the behaviour of different libraries.","vote":"172"}
{"post_id":"1116273","Title":"How do I calculate someone's age in Java?","question_id":"1116123","comment":"Don't know *why* I used DateMidnight, and I note now it's deprecated. Now changed to use LocalDate","vote":"172"}
{"post_id":"842900","Title":"Odd behavior when Java converts int to byte?","question_id":"842817","comment":"well done, the best explanation on this subject, Wayne! I'm just looking for the math formalization why in a two's complement representation the sign bit can be copied on the right in order to add bits. It's easy to understand it thinking to the rule of how to obtain the negative of a number. that is: consider all the bits from right to left and write them unchanged till the first 1 comprised. Then invert the subsequent bits. If i consider the missing bit to be 0s, it's easy to understand that they all go to 1. But i was looking for a more 'math' explanation.","vote":"172"}